import os
import abc
import logging
import textwrap

from ipalib.install.dnsforwarders import _SYSTEMD_RESOLV_CONF
from ipaplatform.paths import paths
from . import tasks


logger = logging.getLogger(__name__)


class Resolver(abc.ABC):
    def __init__(self, host):
        self.host = host
        self.backups = []
        self.current_state = self._get_state()

    def setup_resolver(self, nameservers, searchdomains=None):
        if len(self.backups) == 0:
            raise Exception(
                'Changing resolver state without backup is forbidden')
        if isinstance(nameservers, str):
            nameservers = [nameservers]
        if isinstance(searchdomains, str):
            searchdomains = [searchdomains]
        if searchdomains is None:
            searchdomains = []
        state = self._make_state_from_args(nameservers, searchdomains)
        self._set_state(state)

    def backup(self):
        state = self._get_state()
        assert state == self.current_state, (
            'Resolver state changed unexpectedly')
        self.backups.append(state)
        logging.debug(
            'Saved resolver state for host {}, number of saved states: {}'
            .format(self.host, len(self.backups))
        )

    def restore(self):
        if len(self.backups) == 0:
            raise Exception('No backups found')
        assert self._get_state() == self.current_state, (
            'Resolver state changed unexpectedly')
        self._set_state(self.backups.pop())
        logging.debug(
            'Restored resolver state for host {}, number of saved states: {}'
            .format(self.host, len(self.backups))
        )

    def has_backups(self):
        return bool(self.backups)

    def __enter__(self):
        self.backup()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.restore()

    def _set_state(self, state):
        self._apply_state(state)
        self.current_state = state

    @abc.abstractclassmethod
    def is_our_resolver(cls, host):
        pass

    @abc.abstractmethod
    def _make_state_from_args(self, nameservers, searchdomains):
        pass

    @abc.abstractmethod
    def _get_state(self):
        pass

    @abc.abstractmethod
    def _apply_state(self, state):
        pass


class ResolvedResolver(Resolver):
    RESOLVED_CONF_FILE = '/etc/systemd/resolved.conf.d/zzzz-ipatests.conf'
    RESOLVED_CONF = textwrap.dedent('''
        # generated by IPA tests
        [Resolve]
        DNS={nameservers}
        Domains=~. {searchdomains}
    ''')

    @classmethod
    def is_our_resolver(cls, host):
        res = host.run_command(
            ['stat', '--format', '%F', paths.RESOLV_CONF])
        filetype = res.stdout_text.strip()
        if filetype == 'symbolic link':
            res = host.run_command(['realpath', paths.RESOLV_CONF])
            return (res.stdout_text.strip() in _SYSTEMD_RESOLV_CONF)
        return False

    def _restart_resolved(self):
        tasks.run_repeatedly(
            self.host, ['systemctl', 'restart', 'systemd-resolved.service'],
            timeout=15)

    def _make_state_from_args(self, nameservers, searchdomains):
        return {
            'resolved_config': self.RESOLVED_CONF.format(
                nameservers=' '.join(nameservers),
                searchdomains=' '.join(searchdomains))
        }

    def _get_state(self):
        exists = self.host.transport.file_exists(self.RESOLVED_CONF_FILE)
        return {
            'resolved_config':
                self.host.get_file_contents(self.RESOLVED_CONF_FILE, 'utf-8')
                if exists else None
        }

    def _apply_state(self, state):
        if state['resolved_config'] is None:
            self.host.run_command(['rm', '-f', self.RESOLVED_CONF_FILE])
        else:
            self.host.run_command(
                ['mkdir', '-p', os.path.dirname(self.RESOLVED_CONF_FILE)])
            self.host.put_file_contents(
                self.RESOLVED_CONF_FILE, state['resolved_config'])
        self._restart_resolved()


class PlainFileResolver(Resolver):
    IPATESTS_RESOLVER_COMMENT = '# created by ipatests'

    @classmethod
    def is_our_resolver(cls, host):
        res = host.run_command(
            ['stat', '--format', '%F', paths.RESOLV_CONF])
        filetype = res.stdout_text.strip()
        if filetype == 'regular file':
            resolv_conf = host.get_file_contents(paths.RESOLV_CONF, 'utf-8')
            line = resolv_conf.splitlines()[0].strip()
            return not line.startswith('#') or all([
                'resolved' not in line,
                'NetworkManager' not in line
            ])
        return False

    def _make_state_from_args(self, nameservers, searchdomains):
        contents_lines = [self.IPATESTS_RESOLVER_COMMENT]
        contents_lines.extend('nameserver {}'.format(r) for r in nameservers)
        if searchdomains:
            contents_lines.append('search {}'.format(' '.join(searchdomains)))
        contents = '\n'.join(contents_lines)
        return {'resolv_conf': contents}

    def _get_state(self):
        return {
            'resolv_conf': self.host.get_file_contents(
                paths.RESOLV_CONF, 'utf-8')
        }

    def _apply_state(self, state):
        self.host.put_file_contents(paths.RESOLV_CONF, state['resolv_conf'])


# The version of NM resolver manager which sets name servers using
# config files in /etc/NetworkManager/conf.d instead of diasbling dns managemnt
# The issue with this aproach is that it take a little time for
# resolv.conf to be updated after NM restart. I want to avoid using time.sleep
# so searching for a better solution.

# class NetworkManagerResolver(Resolver):
#     NM_CONF_FILE = '/etc/NetworkManager/conf.d/zzzz-ipatests.conf'
#     NM_CONF = textwrap.dedent('''
#         # generated by IPA tests
#         [main]
#         dns=default
#
#         [global-dns]
#         searches={searchdomains}
#
#         [global-dns-domain-*]
#         servers={nameservers}
#     ''')
#
#     @classmethod
#     def is_our_resolver(cls, host):
#         res = host.run_command(
#             ['stat', '--format', '%F', paths.RESOLV_CONF])
#         filetype = res.stdout_text.strip()
#         if filetype == 'regular file':
#             resolv_conf = host.get_file_contents(paths.RESOLV_CONF, 'utf-8')
#             return resolv_conf.startswith('# Generated by NetworkManager')
#         return False
#
#     def _restart_network_manager(self):
#         tasks.run_repeatedly(
#             self.host, ['systemctl', 'restart', 'NetworkManager.service'],
#             timeout=15)
#
#     def _make_state_from_args(self, nameservers, searchdomains):
#         return {'nm_config': self.NM_CONF.format(
#             nameservers=','.join(nameservers),
#             searchdomains=','.join(searchdomains))}
#
#     def _get_state(self):
#         exists = self.host.transport.file_exists(self.NM_CONF_FILE)
#         return {
#             'nm_config':
#                 self.host.get_file_contents(self.NM_CONF_FILE, 'utf-8')
#                 if exists else None
#         }
#
#     def _apply_state(self, state):
#         if state['nm_config'] is None:
#             self.host.run_command(['rm', '-f', self.NM_CONF_FILE])
#         else:
#             self.host.run_command(
#                 ['mkdir', '-p', os.path.dirname(self.NM_CONF_FILE)])
#             self.host.put_file_contents(
#                 self.NM_CONF_FILE, state['nm_config'])
#         self._restart_network_manager()


class NetworkManagerResolver(PlainFileResolver):
    NM_CONF_FILE = '/etc/NetworkManager/conf.d/zzzz-ipatests.conf'
    NM_CONF = textwrap.dedent('''
        [main]
        dns=none
    ''')

    @classmethod
    def is_our_resolver(cls, host):
        res = host.run_command(
            ['stat', '--format', '%F', paths.RESOLV_CONF])
        filetype = res.stdout_text.strip()
        if filetype == 'regular file':
            resolv_conf = host.get_file_contents(paths.RESOLV_CONF, 'utf-8')
            return resolv_conf.startswith('# Generated by NetworkManager')
        return False

    def _restart_network_manager(self):
        tasks.run_repeatedly(
            self.host, ['systemctl', 'restart', 'NetworkManager.service'],
            timeout=15)

    def _make_state_from_args(self, nameservers, serchdomains):
        state = super()._make_state_from_args(nameservers, serchdomains)
        state['dns_management_disabled'] = True
        return state

    def _get_state(self):
        state = super()._get_state()
        state['dns_management_disabled'] = self.host.transport.file_exists(
            self.NM_CONF_FILE)
        return state

    def _apply_state(self, state):
        if state['dns_management_disabled']:
            self.host.put_file_contents(
                self.NM_CONF_FILE, self.NM_CONF)
        else:
            self.host.run_command(['rm', '-f', self.NM_CONF_FILE])
        super()._apply_state(state)
        self._restart_network_manager()


def resolver(host):
    for cls in [ResolvedResolver, NetworkManagerResolver,
                PlainFileResolver]:
        if cls.is_our_resolver(host):
            logger.info('Detected DNS resolver manager for host %s is %s',
                        host.hostname, cls)
            return cls(host)
    raise Exception('Resolver manager could not be detected')
